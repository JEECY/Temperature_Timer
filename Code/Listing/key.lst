C51 COMPILER V9.00   KEY                                                                   01/21/2016 00:22:21 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE KEY
OBJECT MODULE PLACED IN .\Output\key.obj
COMPILER INVOKED BY: E:\ARM\C51\BIN\C51.EXE User\key.c COMPACT BROWSE DEBUG OBJECTEXTEND PRINT(.\Listing\key.lst) TABS(2
                    -) OBJECT(.\Output\key.obj)

line level    source

   1          #include "key.h"
   2          uchar R=0,R1=0,R2=0,b=0,b1=0,b2=0,e=0;
   3          uchar LQ=0,MB=0,H4=0,K4=0,F4=0,MB1=0,MB2=0,MB3=0,MB4=0,FL1=0,FL2=0,KL1=0,KL2=0,HL1=0,HL2=0;
   4          uchar hour=0,temp=0;
   5          uchar ZD=0,ZD1=0;
   6          uchar j1=0,j2=0,H1=0,H2=0,q1=0,q2=0,DS=0,DS1=0;
   7          uchar date=0,day=0,month=0,year=0,Y2=0,Y1=0,N1=0,N2=0,R11=0,R21=0;
   8          void into1(void);
   9          void into1_1(void);
  10          void into1_2(void);
  11          void into1_21(void);
  12          void into2(void);
  13          void into3(void);
  14          void into3_1(void);
  15          void into3_2(void);
  16          void into3_21(void);
  17          void into3_3(void);
  18          void into3_31(void);
  19          void into3_4(void);
  20          void menu_move1()
  21          {
  22   1        if(KZ==0)
  23   1        {
  24   2        delay(5);
  25   2        if(KZ==0)
  26   2          {
  27   3          red=0;
  28   3          delay(5);
  29   3          red=1;
  30   3          b++;
  31   3          }
  32   2        while(!KZ);
  33   2        }
  34   1        if(b==1)
  35   1        {
  36   2        OLED_P16x16Ch(0,0,15);   //箭头
  37   2        OLED_P16x16Ch(0,3,28);   //清除箭头   
  38   2        OLED_P16x16Ch(0,6,28);
  39   2        R=1;
  40   2        }
  41   1        if(b==2)
  42   1        {
  43   2        OLED_P16x16Ch(0,3,15);   //箭头
  44   2        OLED_P16x16Ch(0,0,28);   //清除箭头   
  45   2        OLED_P16x16Ch(0,6,28);
  46   2        R=2;
  47   2        }
  48   1        if(b==3)
  49   1        {
  50   2        OLED_P16x16Ch(0,6,15);   //箭头
  51   2        OLED_P16x16Ch(0,3,28);   //清除箭头   
  52   2        OLED_P16x16Ch(0,0,28);
  53   2        R=3;
  54   2        b=0;
C51 COMPILER V9.00   KEY                                                                   01/21/2016 00:22:21 PAGE 2   

  55   2        }          
  56   1      }
  57          
  58          void menu_move2()
  59          {
  60   1        if(KZ==0)
  61   1        {
  62   2        delay(5);
  63   2        if(KZ==0)
  64   2          {
  65   3          red=0;
  66   3          delay(5);
  67   3          red=1;
  68   3          b1++;
  69   3          }
  70   2          while(!KZ);
  71   2        }
  72   1        if(b1==1)
  73   1        {
  74   2        OLED_P16x16Ch(0,0,15);   //箭头
  75   2        OLED_P16x16Ch(0,2,28);   //清除箭头   
  76   2        OLED_P16x16Ch(0,4,28);
  77   2        OLED_P16x16Ch(0,6,28);
  78   2        R1=1;
  79   2        }
  80   1        if(b1==2)
  81   1        {
  82   2        OLED_P16x16Ch(0,2,15);   //箭头
  83   2        OLED_P16x16Ch(0,0,28);   //清除箭头   
  84   2        OLED_P16x16Ch(0,6,28);
  85   2        OLED_P16x16Ch(0,4,28);
  86   2        R1=2;
  87   2        }
  88   1        if(b1==3)
  89   1        {
  90   2        OLED_P16x16Ch(0,4,15);   //箭头
  91   2        OLED_P16x16Ch(0,2,28);   //清除箭头   
  92   2        OLED_P16x16Ch(0,0,28);
  93   2        OLED_P16x16Ch(0,6,28);
  94   2        R1=3;
  95   2        }
  96   1        if(b1==4)
  97   1        {
  98   2        OLED_P16x16Ch(0,6,15);   //箭头
  99   2        OLED_P16x16Ch(0,0,28);   //清除箭头   
 100   2        OLED_P16x16Ch(0,2,28);
 101   2        OLED_P16x16Ch(0,4,28);
 102   2        R1=4;
 103   2        b1=0;
 104   2        }          
 105   1      }
 106          
 107          void menu_move3()
 108          {
 109   1        if(KZ==0)
 110   1        {
 111   2        delay(5);
 112   2        if(KZ==0)
 113   2          {
 114   3          red=0;
 115   3          delay(5);
 116   3          red=1;
C51 COMPILER V9.00   KEY                                                                   01/21/2016 00:22:21 PAGE 3   

 117   3          b2++;
 118   3          }
 119   2          while(!KZ);
 120   2        }
 121   1        if(b2==1)
 122   1        {
 123   2        OLED_P16x16Ch(0,2,15);   //箭头
 124   2        OLED_P16x16Ch(0,5,28);   //清除箭头   
 125   2        R2=1;          //"成功"
 126   2        }
 127   1        if(b2==2)
 128   1        {
 129   2        OLED_P16x16Ch(0,5,15);   //箭头
 130   2        OLED_P16x16Ch(0,2,28);   //清除箭头   
 131   2        R2=2;
 132   2        b2=0;          //“取消”
 133   2        }          
 134   1      
 135   1      }
 136          //-----------------------
 137          //    跳转至界面1
 138          //-----------------------
 139          void into1()
 140          {
 141   1        if(KQ==0)
 142   1        {
 143   2          delay(5);
 144   2          if(KQ==0)
 145   2          {
 146   3            OLED_CLS(0);
 147   3            e=1;  
 148   3            while(e==1)
 149   3            {
 150   4              ping1();
 151   4              menu_move1();
 152   4              into2();
 153   4              if(KY==0)   //返回
 154   4              {
 155   5                delay(5);
 156   5                if(KY==0)
 157   5                {
 158   6                  OLED_CLS(0);
 159   6                  break;
 160   6                }
 161   5              } 
 162   4            }
 163   3            b=0;R=0;  
 164   3          }
 165   2        }
 166   1      }
 167          //+++++++++++++++++++++++
 168          //    日期调整
 169          void into1_1()
 170          {
 171   1      if((R==2)&&(KQ==0))
 172   1        {
 173   2        delay(10);
 174   2        if(KQ==0)
 175   2          {
 176   3          OLED_CLS(0);
 177   3          getting();
 178   3              xianshi2_DS1302();
C51 COMPILER V9.00   KEY                                                                   01/21/2016 00:22:21 PAGE 4   

 179   3          while(R==2)
 180   3            {
 181   4          if(KZ==0)
 182   4            {
 183   5            delay(10);
 184   5            if(KZ==0)
 185   5              {
 186   6              red=0;
 187   6              delay(10);
 188   6              red=1;
 189   6              date++;
 190   6              if(date==4)
 191   6              date=1;
 192   6              }
 193   5              while(!KZ);
 194   5            }
 195   4            
 196   4          if((date==1)&&(KS==0))              //年加
 197   4            {
 198   5                   delay(10);
 199   5             if(KS==0)
 200   5              {
 201   6              red=0;
 202   6              delay(50);
 203   6              red=1;
 204   6                      temp=time[6]/16;
 205   6              time[6]=time[6]%16+temp*10;    //进行BCD数到十进制数的转换
 206   6              if(time[6]<99)
 207   6              time[6]++;
 208   6      
 209   6              else
 210   6              time[6]=0;
 211   6              year=time[6];
 212   6      
 213   6              temp=time[6]/10;
 214   6              time[6]=time[6]%10+temp*16;   //再转换回BCD数
 215   6              OLED_P6x8Str(25,5,"2");
 216   6              OLED_P6x8Str(31,5,"0");
 217   6              OLED_RYN2(37,5,"0",N2,6);
 218   6              OLED_RYN1(45,5,"0",N1,6);       
 219   6              }
 220   5              while(!KS);
 221   5            }
 222   4      
 223   4          if((date==1)&&(KX==0))              //年减
 224   4            {
 225   5                   delay(10);
 226   5             if(KX==0)
 227   5              {
 228   6              red=0;
 229   6              delay(50);
 230   6              red=1;
 231   6                      temp=time[6]/16;
 232   6              time[6]=time[6]%16+temp*10;    //进行BCD数到十进制数的转换
 233   6              if(time[6]>0)
 234   6              time[6]--;
 235   6      
 236   6              else
 237   6              time[6]=99;
 238   6              year=time[6];
 239   6      
 240   6              temp=time[6]/10;
C51 COMPILER V9.00   KEY                                                                   01/21/2016 00:22:21 PAGE 5   

 241   6              time[6]=time[6]%10+temp*16;   //再转换回BCD数
 242   6              OLED_P6x8Str(25,5,"2");
 243   6              OLED_P6x8Str(31,5,"0");
 244   6              OLED_RYN2(37,5,"0",N2,6);
 245   6              OLED_RYN1(45,5,"0",N1,6);       
 246   6              }
 247   5              while(!KX);
 248   5            }
 249   4      
 250   4          if((date==2)&&(KS==0))              //月加
 251   4            {
 252   5                   delay(10);
 253   5             if(KS==0)
 254   5              {
 255   6              red=0;
 256   6              delay(50);
 257   6              red=1;
 258   6                      temp=time[4]/16;
 259   6              time[4]=time[4]%16+temp*10;    //进行BCD数到十进制数的转换
 260   6              if(time[4]<12)
 261   6              time[4]++;
 262   6      
 263   6              else
 264   6              time[4]=1;
 265   6              month=time[4];
 266   6      
 267   6              temp=time[4]/10;
 268   6              time[4]=time[4]%10+temp*16;   //再转换回BCD数
 269   6              OLED_RYN2(61,5,"0",Y2,4);
 270   6              OLED_RYN1(69,5,"0",Y1,4);       
 271   6              }
 272   5              while(!KS);
 273   5            }
 274   4          if((date==2)&&(KX==0))              //月减
 275   4            {
 276   5                   delay(10);
 277   5             if(KX==0)
 278   5              {
 279   6              red=0;
 280   6              delay(50);
 281   6              red=1;
 282   6                      temp=time[4]/16;
 283   6              time[4]=time[4]%16+temp*10;    //进行BCD数到十进制数的转换
 284   6              if(time[4]>1)
 285   6              time[4]--;
 286   6      
 287   6              else
 288   6              time[4]=12;
 289   6              month=time[4];
 290   6      
 291   6              temp=time[4]/10;
 292   6              time[4]=time[4]%10+temp*16;   //再转换回BCD数
 293   6              OLED_RYN2(61,5,"0",Y2,4);
 294   6              OLED_RYN1(69,5,"0",Y1,4);       
 295   6              }
 296   5              while(!KX);
 297   5            }
 298   4      
 299   4          if((date==3)&&(KS==0))              //日期加
 300   4            {
 301   5                   delay(10);
 302   5             if(KS==0)
C51 COMPILER V9.00   KEY                                                                   01/21/2016 00:22:21 PAGE 6   

 303   5              {
 304   6              red=0;
 305   6              delay(10);
 306   6              red=1;
 307   6                      temp=time[3]/16;
 308   6              time[3]=time[3]%16+temp*10;    //进行BCD数到十进制数的转换
 309   6              if(((month==1)||(month==3)||(month==5)||(month==7)||(month==8)||(month==10)||(month==12))&&(time[3]<32
             -))
 310   6                {
 311   7                time[3]++;
 312   7                if(time[3]==32)
 313   7                time[3]=1;     
 314   7                }
 315   6      
 316   6           else if((year/400==0)&&(month==2)&&(time[3]<29))      //闰年判断
 317   6              {
 318   7              time[3]++;
 319   7              if(time[3]==29)
 320   7              time[3]=1;
 321   7              }
 322   6      
 323   6           else if((year/400!=0)&&(month==2)&&(time[3]<30))      //非闰年判断
 324   6              {
 325   7              time[3]++;
 326   7              if(time[3]==30)
 327   7              time[3]=1;
 328   7              }
 329   6      
 330   6           else if((time[3]<31)&&((month==4)||(month==6)||(month==9)||(month==11)))
 331   6            {
 332   7              time[3]++;
 333   7              if(time[3]==31)
 334   7              time[3]=1;
 335   7            }
 336   6      
 337   6              day=time[3];
 338   6      
 339   6              temp=time[3]/10;
 340   6              time[3]=time[3]%10+temp*16;   //再转换回BCD数
 341   6                      OLED_RYN2(85,5,"0",R21,3);
 342   6              OLED_RYN1(93,5,"0",R11,3);        
 343   6              }
 344   5              while(!KS);
 345   5            }
 346   4      
 347   4          if((date==3)&&(KX==0))              //日期减
 348   4            {
 349   5                   delay(10);
 350   5             if(KX==0)
 351   5              {
 352   6              red=0;
 353   6              delay(10);
 354   6              red=1;
 355   6                       temp=time[3]/16;
 356   6              time[3]=time[3]%16+temp*10;    //进行BCD数到十进制数的转换
 357   6              if(((month==1)||(month==3)||(month==5)||(month==7)||(month==8)||(month==10)||(month==12))&&(time[3]>0)
             -)
 358   6                {
 359   7                time[3]--;
 360   7                if(time[3]==0)
 361   7                time[3]=31;    
 362   7                }
C51 COMPILER V9.00   KEY                                                                   01/21/2016 00:22:21 PAGE 7   

 363   6      
 364   6           else if((year/400==0)&&(month==2)&&(time[3]>0))       //闰年判断
 365   6              {
 366   7              time[3]--;
 367   7              if(time[3]==0)
 368   7              time[3]=28;
 369   7              }
 370   6      
 371   6           else if((year/400!=0)&&(month==2)&&(time[3]>0))       //非闰年判断
 372   6              {
 373   7              time[3]--;
 374   7              if(time[3]==0)
 375   7              time[3]=29;
 376   7              }
 377   6      
 378   6           else if((time[3]>0)&&((month==4)||(month==6)||(month==9)||(month==11)))
 379   6            {
 380   7              time[3]--;
 381   7              if(time[3]==0)
 382   7              time[3]=30;
 383   7            }
 384   6      
 385   6              day=time[3];
 386   6      
 387   6              temp=time[3]/10;
 388   6              time[3]=time[3]%10+temp*16;   //再转换回BCD数
 389   6                      OLED_RYN2(85,5,"0",R21,3);
 390   6              OLED_RYN1(93,5,"0",R11,3);        
 391   6              }
 392   5              while(!KX);
 393   5            }
 394   4            
 395   4           else if((KY==0)&&(date==1))
 396   4              {
 397   5            delay(10);
 398   5            if(KY==0)
 399   5              {
 400   6              red=0;
 401   6              delay(10);
 402   6              red=1;
 403   6              write_1302(0x8e,0x00);
 404   6              write_1302(0x8c,time[6]);    //年
 405   6              write_1302(0x88,time[4]);    //月
 406   6              write_1302(0x86,time[3]);        //日
 407   6              write_1302(0x8e,0x80);
 408   6              OLED_CLS(0);
 409   6              OLED_P16x16Ch(48,4,29);
 410   6              OLED_P16x16Ch(66,4,30);
 411   6              delay(6000);
 412   6              OLED_CLS(0);
 413   6              break;
 414   6              }
 415   5            
 416   5            }
 417   4           else if((KY==0)&&(date==2))
 418   4              {
 419   5            delay(10);
 420   5            if(KY==0)
 421   5              {
 422   6              red=0;
 423   6              delay(10);
 424   6              red=1;
C51 COMPILER V9.00   KEY                                                                   01/21/2016 00:22:21 PAGE 8   

 425   6              OLED_CLS(0);
 426   6              OLED_P16x16Ch(48,4,31);
 427   6              OLED_P16x16Ch(66,4,32);
 428   6              delay(6000);
 429   6              OLED_CLS(0);
 430   6              break;
 431   6              }
 432   5            
 433   5            }                                     
 434   4            }
 435   3          }
 436   2        }
 437   1      } 
 438          //+++++++++++++++++++++++
 439          //    温度显示
 440          void into1_2()
 441          {
 442   1        if((R==3)&&(KQ==0))
 443   1          {
 444   2        delay(10);
 445   2        if(KQ==0)
 446   2          {
 447   3           OLED_CLS(0);
 448   3           OLED_P16x16Ch(24,2,33);
 449   3           OLED_P16x16Ch(40,2,34);
 450   3           OLED_P16x16Ch(24,5,31);
 451   3           OLED_P16x16Ch(40,5,32);
 452   3           while(R==3)
 453   3            {
 454   4            menu_move3();
 455   4            if(KY==0)
 456   4              {
 457   5            delay(10);
 458   5            if(KY==0)
 459   5              {
 460   6              OLED_CLS(0);
 461   6              OLED_P16x16Ch(50,4,29);
 462   6              OLED_P16x16Ch(78,4,30);
 463   6              delay(6000);
 464   6              OLED_CLS(0);
 465   6              break;
 466   6              }
 467   5            }
 468   4            }   
 469   3          }
 470   2        }
 471   1      }
 472          void into1_21()
 473          {
 474   1        if(R2==1)
 475   1          {
 476   2          search_DS18B20();   
 477   2          xianshi_DS18B20();    //温度显示
 478   2          }
 479   1        if(R2==2)
 480   1        OLED_P8x16Str(0,0,"        ");
 481   1      }
 482          
 483          //-----------------------
 484          //    跳转至界面2
 485          //-----------------------
 486          void into2()
C51 COMPILER V9.00   KEY                                                                   01/21/2016 00:22:21 PAGE 9   

 487          {
 488   1        if((R==1)&&(KQ==0))
 489   1        {
 490   2          delay(5);
 491   2          if(KQ==0)
 492   2          {
 493   3            OLED_CLS(0);
 494   3            while(R==1)
 495   3            {
 496   4              ping2();
 497   4              menu_move2();
 498   4              into3();
 499   4              if(KY==0)
 500   4              {
 501   5                delay(5);
 502   5                if(KY==0)
 503   5                {
 504   6                  OLED_CLS(0);
 505   6                  break;
 506   6                }
 507   5              } 
 508   4            }
 509   3           b1=0;R1=0;
 510   3          }
 511   2        }
 512   1      into1_1();   //日期调整          
 513   1      into1_2();   
 514   1      }
 515          //+++++++++++++++++++++++
 516          //    界面2功能区
 517          //+++++++++++++++++++++++
 518          void into3()
 519          {
 520   1       into3_1();
 521   1       into3_2();
 522   1       into3_3();
 523   1       into3_4();
 524   1      }
 525          //+++++++++++++++++++++++
 526          //    时间调整
 527          void into3_1() 
 528          {
 529   1      if((R1==1)&&(KQ==0))
 530   1        {
 531   2        delay(10);
 532   2        if(KQ==0)
 533   2          {
 534   3          OLED_CLS(0);
 535   3          hour=1;
 536   3          getting();
 537   3          time[0]=0;
 538   3            xianshi1_DS1302();        //显示日期
 539   3          while(R1==1)
 540   3          { 
 541   4          if(KZ==0)   //选择时位，分位
 542   4          {
 543   5          delay(10);
 544   5          if(KZ==0)
 545   5            {
 546   6              red=0;
 547   6              delay(10);
 548   6              red=1;
C51 COMPILER V9.00   KEY                                                                   01/21/2016 00:22:21 PAGE 10  

 549   6            hour=~hour;            //取反
 550   6            }
 551   5            while(!KZ);
 552   5          }
 553   4           
 554   4           if((KS==0)&&(hour==1))        //时加
 555   4           {
 556   5           delay(10);
 557   5           if(KS==0)
 558   5            {   
 559   6              red=0;
 560   6              delay(10);
 561   6              red=1;        
 562   6              temp=time[2]/16;
 563   6              time[2]=time[2]%16+temp*10;    //进行BCD数到十进制数的转换
 564   6              if(time[2]<23)
 565   6              time[2]++;
 566   6      
 567   6              else
 568   6              time[2]=0;
 569   6      
 570   6              temp=time[2]/10;
 571   6              time[2]=time[2]%10+temp*16;   //再转换回BCD数
 572   6              OLED_MFS2(24,3,"0",S2,2);
 573   6                      OLED_MFS1(32,3,"0",S1,2);
 574   6            } 
 575   5            while(!KS);
 576   5          }
 577   4      
 578   4          else if((KS==0)&&(hour==-2))              //分加
 579   4             {
 580   5              delay(10);
 581   5              if(KS==0)
 582   5              {
 583   6              red=0;
 584   6              delay(10);
 585   6              red=1;
 586   6              temp=time[1]/16;
 587   6              time[1]=time[1]%16+temp*10;    //进行BCD数到十进制数的转换
 588   6              if(time[1]<59)
 589   6              time[1]++;
 590   6      
 591   6              else
 592   6              time[1]=0;
 593   6      
 594   6              temp=time[1]/10;
 595   6              time[1]=time[1]%10+temp*16;
 596   6              OLED_MFS2(56,3,"0",F2,1);
 597   6                      OLED_MFS1(64,3,"0",F1,1); 
 598   6              }
 599   5              while(!KS);
 600   5             }
 601   4      
 602   4      
 603   4           else if((KX==0)&&(hour==1))        //时减
 604   4            {
 605   5                
 606   5                 delay(10);
 607   5                   if(KX==0)
 608   5              {
 609   6              red=0;
 610   6              delay(10);
C51 COMPILER V9.00   KEY                                                                   01/21/2016 00:22:21 PAGE 11  

 611   6              red=1;
 612   6              temp=time[2]/16;
 613   6              time[2]=time[2]%16+temp*10;    //进行BCD数到十进制数的转换
 614   6              if(time[2]>0)
 615   6              time[2]--;
 616   6      
 617   6              else
 618   6              time[2]=23;
 619   6      
 620   6              temp=time[2]/10;
 621   6              time[2]=time[2]%10+temp*16;   //再转换回BCD数
 622   6              OLED_MFS2(24,3,"0",S2,2);
 623   6                      OLED_MFS1(32,3,"0",S1,2);
 624   6              }
 625   5              while(!KX);
 626   5            } 
 627   4      
 628   4          else if((KX==0)&&(hour==-2))         //分减
 629   4             {
 630   5                delay(10);
 631   5                  if(KX==0)
 632   5              {
 633   6              red=0;
 634   6              delay(10);
 635   6              red=1;
 636   6              temp=time[1]/16;
 637   6              time[1]=time[1]%16+temp*10;    //进行BCD数到十进制数的转换
 638   6              if(time[1]>0)
 639   6              time[1]--;
 640   6      
 641   6              else
 642   6              time[1]=59;
 643   6      
 644   6              temp=time[1]/10;
 645   6              time[1]=time[1]%10+temp*16;
 646   6              OLED_MFS2(56,3,"0",F2,1);
 647   6                      OLED_MFS1(64,3,"0",F1,1); 
 648   6              }
 649   5              while(!KX);
 650   5             }
 651   4      
 652   4            else if((KY==0)&&(hour==1))         //修改成功
 653   4            {
 654   5            delay(10);
 655   5            if(KY==0)
 656   5              {
 657   6              write_1302(0x8e,0x00);
 658   6              write_1302(0x84,time[2]);
 659   6              write_1302(0x82,time[1]);
 660   6              write_1302(0x80,time[0]);
 661   6              write_1302(0x8e,0x80);
 662   6              OLED_CLS(0);
 663   6              OLED_P16x16Ch(48,4,29);
 664   6              OLED_P16x16Ch(66,4,30);
 665   6              delay(6000);
 666   6              OLED_CLS(0);
 667   6              break;
 668   6              }
 669   5            }
 670   4      
 671   4            else if((KY==0)&&(hour==-2))           //取消修改
 672   4            {
C51 COMPILER V9.00   KEY                                                                   01/21/2016 00:22:21 PAGE 12  

 673   5            delay(10);
 674   5            if(KY==0)
 675   5              {
 676   6              OLED_CLS(0);
 677   6              OLED_P16x16Ch(48,4,31);
 678   6              OLED_P16x16Ch(66,4,32);
 679   6              delay(6000);
 680   6              OLED_CLS(0);
 681   6              break;
 682   6              }
 683   5            }   
 684   4          }
 685   3        }
 686   2      
 687   2      }    }
 688          //+++++++++++++++++++++++
 689          //    整点报时
 690          void into3_2()
 691          {
 692   1      if((R1==2)&&(KQ==0))
 693   1        {
 694   2        delay(10);
 695   2        if(KQ==0)
 696   2          {
 697   3          OLED_CLS(0);
 698   3          OLED_P16x16Ch(20,2,26);
 699   3          OLED_P16x16Ch(20,5,27);
 700   3          while(R1==2)
 701   3            {
 702   4            if(KZ==0)
 703   4              {
 704   5              delay(10);
 705   5              if(KZ==0)
 706   5                {
 707   6              red=0;
 708   6              delay(10);
 709   6              red=1;
 710   6              ZD++;
 711   6              if(ZD==3)
 712   6              ZD=1;
 713   6                }
 714   5                while(!KZ);
 715   5              }
 716   4      
 717   4              if(ZD==1)
 718   4              {
 719   5              OLED_P16x16Ch(0,2,15);   //箭头
 720   5              OLED_P16x16Ch(0,5,28);   //清除箭头
 721   5              ZD1=1;
 722   5              }
 723   4              if(ZD==2)
 724   4                {
 725   5              OLED_P16x16Ch(0,5,15);   //箭头
 726   5              OLED_P16x16Ch(0,2,28);   //清除箭头
 727   5              ZD1=2;
 728   5                }
 729   4                                        
 730   4              if(KY==0)
 731   4                {
 732   5                delay(10);
 733   5                if(KY==0)
 734   5                  {
C51 COMPILER V9.00   KEY                                                                   01/21/2016 00:22:21 PAGE 13  

 735   6              OLED_CLS(0);
 736   6              OLED_P16x16Ch(48,4,29);
 737   6              OLED_P16x16Ch(66,4,30);
 738   6              delay(6000);
 739   6              OLED_CLS(0);
 740   6              break;
 741   6                  }
 742   5                }
 743   4              }
 744   3          }
 745   2        }
 746   1      }
 747          void into3_21()
 748          {
 749   1      OLED_P16x16Ch(90,0,28);   //清除图标
 750   1      if(ZD1==1)
 751   1        {
 752   2        OLED_P16x16Ch(90,0,35);      //开启整点报时的图标
 753   2        if((time[1]==0)&&(time[0]==0))  
 754   2          {
 755   3          BS();
 756   3          }
 757   2        }
 758   1      
 759   1      if(ZD1==2)
 760   1        {
 761   2        OLED_P16x16Ch(90,0,36);      //关整点报时的图标
 762   2        if((time[1]==0)&&(time[0]==0))  
 763   2          {
 764   3          yellow=1;
 765   3          beep=1;
 766   3          }
 767   2        }
 768   1      }
 769          //+++++++++++++++++++++++
 770          //    闹钟
 771          void into3_3()
 772          {
 773   1      if((R1==3)&&(KQ==0))
 774   1        {
 775   2        delay(10);
 776   2        if(KQ==0)
 777   2          {
 778   3          OLED_CLS(0);
 779   3          OLED_MB1(40,3,"0",j1,H2);    
 780   3          OLED_MB2(48,3,"0",j2,H2);
 781   3          OLED_P16x16Ch(56,3,2);
 782   3          OLED_MB1(72,3,"0",q1,H1);    
 783   3          OLED_MB2(80,3,"0",q2,H1);
 784   3      
 785   3          OLED_P16x16Ch(20,6,26);
 786   3          OLED_P16x16Ch(100,6,27);
 787   3          while(R1==3)
 788   3              {
 789   4            if(KZ==0)
 790   4              {
 791   5              delay(10);
 792   5              if(KZ==0)
 793   5                {
 794   6                red=0;
 795   6                delay(10);
 796   6                red=1;
C51 COMPILER V9.00   KEY                                                                   01/21/2016 00:22:21 PAGE 14  

 797   6                DS++;
 798   6                if(DS==5)
 799   6                DS=1; 
 800   6                }
 801   5                while(!KZ);
 802   5              }
 803   4              if((DS==1)&&(KS==0))         //时设定（加）
 804   4                {
 805   5                delay(10);
 806   5                if(KS==0)
 807   5                  {
 808   6                  if(H2<23)
 809   6                  H2++;
 810   6      
 811   6                  else
 812   6                  H2=0;
 813   6                  OLED_MB1(40,3,"0",j1,H2);    
 814   6                  OLED_MB2(48,3,"0",j2,H2);
 815   6                  }
 816   5                  while(!KS);
 817   5                }
 818   4              if((DS==1)&&(KX==0))         //时设定（减）
 819   4                {
 820   5                delay(10);
 821   5                if(KX==0)
 822   5                  {
 823   6                              if(H2>0)
 824   6                  H2--;
 825   6                  
 826   6                  else
 827   6                  H2=23;
 828   6                  OLED_MB1(40,3,"0",j1,H2);    
 829   6                  OLED_MB2(48,3,"0",j2,H2);
 830   6                  }
 831   5                  while(!KX);
 832   5                }
 833   4      
 834   4      
 835   4              if((DS==2)&&(KS==0))         //分设定（加）
 836   4                {
 837   5                delay(10);
 838   5                if(KS==0)
 839   5                  {
 840   6                  if(H1<59)
 841   6                  H1++;
 842   6      
 843   6                  else
 844   6                  H1=0;
 845   6                  OLED_MB1(72,3,"0",q1,H1);    
 846   6                  OLED_MB2(80,3,"0",q2,H1);
 847   6                  }
 848   5                  while(!KS);
 849   5                }
 850   4              if((DS==2)&&(KX==0))         //分设定（减）
 851   4                {
 852   5                delay(10);
 853   5                if(KX==0)
 854   5                  {
 855   6                  if(H1>0)
 856   6                  H1--;
 857   6                  else
 858   6                  H1=59;
C51 COMPILER V9.00   KEY                                                                   01/21/2016 00:22:21 PAGE 15  

 859   6      
 860   6                  OLED_MB1(72,3,"0",q1,H1);    
 861   6                  OLED_MB2(80,3,"0",q2,H1);
 862   6                  }
 863   5                  while(!KX);
 864   5                }
 865   4      
 866   4               if(DS==3)
 867   4                {
 868   5                  OLED_P16x16Ch(0,6,15);   //箭头
 869   5                  OLED_P16x16Ch(84,6,28);  //清除箭头
 870   5                  DS1=1;  
 871   5                }
 872   4              if(DS==4)
 873   4                {
 874   5                  OLED_P16x16Ch(84,6,15);  //箭头
 875   5                  OLED_P16x16Ch(0,6,28);   //清除箭头                   
 876   5                  DS1=2;
 877   5                }
 878   4      
 879   4              if((DS==1)||(DS==2))
 880   4                {
 881   5                OLED_P16x16Ch(0,6,28);   //清除箭头
 882   5                OLED_P16x16Ch(84,6,28);  //清除箭头
 883   5                }
 884   4              if(KY==0)
 885   4                {
 886   5                delay(10);
 887   5                if((KY==0)&&((DS==1)||(DS==2)))
 888   5                  {
 889   6                   OLED_CLS(0);
 890   6                   OLED_P16x16Ch(48,4,31);  //取消 
 891   6                   OLED_P16x16Ch(80,4,32);
 892   6                   delay(6000);
 893   6                   OLED_CLS(0); 
 894   6                   break;
 895   6                  }
 896   5                }
 897   4      
 898   4              if((KY==0)&&((DS==4)||(DS==3)))
 899   4                {
 900   5                delay(10);
 901   5                if(KY==0)
 902   5                  {
 903   6                   OLED_CLS(0);
 904   6                   OLED_P16x16Ch(48,4,29);  //成功 
 905   6                   OLED_P16x16Ch(80,4,30);
 906   6                   delay(6000);
 907   6                   OLED_CLS(0); 
 908   6                   break;
 909   6                  }
 910   5                }       
 911   4            }
 912   3          }
 913   2        }
 914   1      }
 915          void into3_31()//定时判断
 916          {
 917   1        temp=time[1]/16;
 918   1        time[1]=time[1]%16+temp*10;    //进行BCD数到十进制数的转换
 919   1        temp=time[2]/16;
 920   1        time[2]=time[2]%16+temp*10;    //进行BCD数到十进制数的转换
C51 COMPILER V9.00   KEY                                                                   01/21/2016 00:22:21 PAGE 16  

 921   1          OLED_P16x16Ch(110,0,28);
 922   1       if(DS1==1)              //开启闹钟
 923   1        {
 924   2        OLED_P16x16Ch(110,0,3);      //图标
 925   2        if((time[2]==H2)&&(time[1]==H1))
 926   2          {
 927   3          temp=time[1]/10;
 928   3          time[1]=time[1]%10+temp*16;
 929   3          temp=time[2]/10;
 930   3          time[2]=time[2]%10+temp*16;
 931   3          while(DS1==1)
 932   3            {
 933   4            OLED_CLS(3);
 934   4            OLED_MFS2(30,3,"0",S2,2);
 935   4            OLED_MFS1(38,3,"0",S1,2);
 936   4            OLED_P16x16Ch(46,3,2);
 937   4            OLED_MFS2(62,3,"0",F2,1);
 938   4            OLED_MFS1(70,3,"0",F1,1);
 939   4            BS();                    //蜂鸣器响
 940   4            delay(1000);
 941   4      
 942   4            if(KY==0)
 943   4              {
 944   5              delay(10);
 945   5              if(KY==0)
 946   5                {
 947   6                H2++;
 948   6                H1++;
 949   6                if(H2==24)
 950   6                H2=0;
 951   6                if(H1==60)
 952   6                H1=0;
 953   6                OLED_CLS(0);
 954   6                break;
 955   6                }
 956   5              }
 957   4            }
 958   3      
 959   3          }
 960   2        }
 961   1      if(DS1==2)              //关闭闹钟
 962   1        {
 963   2        OLED_P16x16Ch(110,0,4);
 964   2        if((time[2]==H2)&&(time[1]==H1))
 965   2          {
 966   3          yellow=1;
 967   3          beep=1;
 968   3          }
 969   2        }
 970   1      }
 971          //+++++++++++++++++++++++
 972          //    秒表
 973          void into3_4()
 974          {
 975   1        if((R1==4)&&(KQ==0))
 976   1        {
 977   2          delay(5);
 978   2          if(KQ==0)
 979   2            {
 980   3            OLED_CLS(0);
 981   3            OLED_P8x16Str(36,0,"0");     //初始化
 982   3            OLED_P8x16Str(44,0,"0");
C51 COMPILER V9.00   KEY                                                                   01/21/2016 00:22:21 PAGE 17  

 983   3            OLED_P8x16Str(52,0,".");
 984   3            OLED_P8x16Str(60,0,"0");     
 985   3            OLED_P8x16Str(68,0,"0");
 986   3            OLED_P8x16Str(76,0,".");
 987   3            OLED_P8x16Str(84,0,"0");
 988   3            OLED_P8x16Str(92,0,"0");
 989   3            while(R1==4)
 990   3            {
 991   4            if(KZ==0)       //开始计时
 992   4              {
 993   5              delay(5);
 994   5              if(KZ==0)
 995   5                {
 996   6                red=0;
 997   6                      delay(50);
 998   6                      red=1;
 999   6                          MB++;
1000   6                if(MB==3)
1001   6                MB=1;
1002   6                        }
1003   5                while(!KZ);
1004   5              }
1005   4            if(MB==1)
1006   4            {
1007   5              if(LQ==20)
1008   5              {
1009   6                LQ=0;
1010   6                H4++;
1011   6               if(H4==60)
1012   6                {
1013   7                  H4=0;
1014   7                  K4++;
1015   7                }
1016   6              if(K4==60)
1017   6                {
1018   7                  K4=0;
1019   7                  F4++;
1020   7                }
1021   6              if(F4==60)
1022   6                {
1023   7                F4=0;
1024   7                } 
1025   6              }
1026   5            }
1027   4            if(MB==2)
1028   4              {
1029   5              
1030   5              }
1031   4            if(KS==0)
1032   4              {
1033   5              delay(5);
1034   5              if(KS==0)
1035   5                {
1036   6                K4=0;
1037   6                H4=0;
1038   6                F4=0;
1039   6                }
1040   5                while(!KS);
1041   5              }
1042   4            OLED_MB1(36,0,"0",FL2,F4);    //时
1043   4            OLED_MB2(44,0,"0",KL2,F4);          
1044   4            OLED_MB1(60,0,"0",KL2,K4);    //分
C51 COMPILER V9.00   KEY                                                                   01/21/2016 00:22:21 PAGE 18  

1045   4            OLED_MB2(68,0,"0",KL1,K4);
1046   4            OLED_MB1(84,0,"0",HL2,H4);      //秒
1047   4            OLED_MB2(92,0,"0",HL1,H4);
1048   4            delay(20);
1049   4      
1050   4          if(KX==0)      //记时
1051   4          {
1052   5            delay(5);
1053   5            if(KX==0)
1054   5              {
1055   6                MB1++;
1056   6                if(MB1==4)
1057   6                MB1=0;
1058   6      
1059   6          if(MB1==1)
1060   6          {
1061   7          MB2=F4;MB3=K4;MB4=H4;
1062   7            OLED_MB1(36,4,"0",FL2,MB2);   //时
1063   7            OLED_MB2(44,4,"0",FL1,MB2);
1064   7            OLED_P8x16Str(52,4,".");          
1065   7            OLED_MB1(60,4,"0",KL2,MB3);   //分
1066   7            OLED_MB2(68,4,"0",KL1,MB3);
1067   7            OLED_P8x16Str(76,4,".");
1068   7            OLED_MB1(84,4,"0",HL2,MB4);     //秒
1069   7            OLED_MB2(92,4,"0",HL1,MB4);   
1070   7          }
1071   6      
1072   6          if(MB1==2)
1073   6          {
1074   7          MB2=F4;MB3=K4;MB4=H4;
1075   7            OLED_MB1(36,6,"0",FL2,MB2);   //时
1076   7            OLED_MB2(44,6,"0",FL1,MB2);
1077   7            OLED_P8x16Str(52,6,".");          
1078   7            OLED_MB1(60,6,"0",KL2,MB3);   //分
1079   7            OLED_MB2(68,6,"0",KL1,MB3);
1080   7            OLED_P8x16Str(76,6,".");
1081   7            OLED_MB1(84,6,"0",HL2,MB4);     //秒
1082   7            OLED_MB2(92,6,"0",HL1,MB4);     
1083   7          }
1084   6      
1085   6          if(MB1==3)
1086   6          {
1087   7              OLED_CLS(4);      
1088   7          }
1089   6              }
1090   5              while(!KX);
1091   5          }
1092   4      
1093   4      
1094   4      
1095   4          if(KY==0)     //返回
1096   4            {
1097   5            delay(5);
1098   5            if(KY==0)
1099   5              {
1100   6              OLED_CLS(0);
1101   6              H4=0;K4=0;F4=0;
1102   6              break;
1103   6              }
1104   5            
1105   5          }                     
1106   4            }
C51 COMPILER V9.00   KEY                                                                   01/21/2016 00:22:21 PAGE 19  

1107   3            }
1108   2        }
1109   1      }
1110          
1111          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   5869    ----
   CONSTANT SIZE    =     15    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =     48    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
